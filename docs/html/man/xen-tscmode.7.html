<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title></title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:root@localhost" />
</head>

<body>



<ul id="index">
  <li><a href="#NAME">NAME</a></li>
  <li><a href="#OVERVIEW">OVERVIEW</a></li>
  <li><a href="#DETERMINING-RDTSC-FREQUENCY">DETERMINING RDTSC FREQUENCY</a></li>
  <li><a href="#TSC-HISTORY">TSC HISTORY</a></li>
  <li><a href="#TSC-INVARIANT-BIT-and-NO_MIGRATE">TSC INVARIANT BIT and NO_MIGRATE</a></li>
  <li><a href="#HARDWARE-TSC-SCALING">HARDWARE TSC SCALING</a></li>
  <li><a href="#AUTHORS">AUTHORS</a></li>
</ul>

<h1 id="NAME">NAME</h1>

<p>xen-tscmode - Xen TSC (time stamp counter) and timekeeping discussion</p>

<h1 id="OVERVIEW">OVERVIEW</h1>

<p>As of Xen 4.0, a new config option called tsc_mode may be specified for each domain. The default for tsc_mode handles the vast majority of hardware and software environments. This document is targeted for Xen users and administrators that may need to select a non-default tsc_mode.</p>

<p>Proper selection of tsc_mode depends on an understanding not only of the guest operating system (OS), but also of the application set that will ever run on this guest OS. This is because tsc_mode applies equally to both the OS and ALL apps that are running on this domain, now or in the future.</p>

<p>Key questions to be answered for the OS and/or each application are:</p>

<ul>

<li><p>Does the OS/app use the rdtsc instruction at all? (We will explain below how to determine this.)</p>

</li>
<li><p>At what frequency is the rdtsc instruction executed by either the OS or any running apps? If the sum exceeds about 10,000 rdtsc instructions per second per processor, we call this a &quot;high-TSC-frequency&quot; OS/app/environment. (This is relatively rare, and developers of OS&#39;s and apps that are high-TSC-frequency are usually aware of it.)</p>

</li>
<li><p>If the OS/app does use rdtsc, will it behave incorrectly if &quot;time goes backwards&quot; or if the frequency of the TSC suddenly changes? If so, we call this a &quot;TSC-sensitive&quot; app or OS; otherwise it is &quot;TSC-resilient&quot;.</p>

</li>
</ul>

<p>This last is the US$64,000 question as it may be very difficult (or, for legacy apps, even impossible) to predict all possible failure cases. As a result, unless proven otherwise, any app that uses rdtsc must be assumed to be TSC-sensitive and, as we will see, this is the default starting in Xen 4.0.</p>

<p>Xen&#39;s new tsc_mode parameter determines the circumstances under which the family of rdtsc instructions are executed &quot;natively&quot; vs emulated. Roughly speaking, native means rdtsc is fast but TSC-sensitive apps may, under unpredictable circumstances, run incorrectly; emulated means there is some performance degradation (unobservable in most cases), but TSC-sensitive apps will always run correctly. Prior to Xen 4.0, all rdtsc instructions were native: &quot;fast but potentially incorrect.&quot; Starting at Xen 4.0, the default is that all rdtsc instructions are &quot;correct but potentially slow&quot;. The tsc_mode parameter in 4.0 provides an intelligent default but allows system administrator&#39;s to adjust how rdtsc instructions are executed differently for different domains.</p>

<p>The non-default choices for tsc_mode are:</p>

<ul>

<li><p><b>tsc_mode=1</b> (always emulate).</p>

<p>All rdtsc instructions are emulated; this is the best choice when TSC-sensitive apps are running and it is necessary to understand worst-case performance degradation for a specific hardware environment.</p>

</li>
<li><p><b>tsc_mode=2</b> (never emulate).</p>

<p>This is the same as prior to Xen 4.0 and is the best choice if it is certain that all apps running in this VM are TSC-resilient and highest performance is required.</p>

</li>
<li><p><b>tsc_mode=3</b> (PVRDTSCP).</p>

<p>This mode has been removed.</p>

</li>
</ul>

<p>If tsc_mode is left unspecified (or set to <b>tsc_mode=0</b>), a hybrid algorithm is utilized to ensure correctness while providing the best performance possible given:</p>

<ul>

<li><p>the requirement of correctness,</p>

</li>
<li><p>the underlying hardware, and</p>

</li>
<li><p>whether or not the VM has been saved/restored/migrated</p>

</li>
</ul>

<p>To understand this in more detail, the rest of this document must be read.</p>

<h1 id="DETERMINING-RDTSC-FREQUENCY">DETERMINING RDTSC FREQUENCY</h1>

<p>To determine the frequency of rdtsc instructions that are emulated, an &quot;xl&quot; command can be used by a privileged user of domain0. The command:</p>

<pre><code>    # xl debug-key s; xl dmesg | tail</code></pre>

<p>provides information about TSC usage in each domain where TSC emulation is currently enabled.</p>

<h1 id="TSC-HISTORY">TSC HISTORY</h1>

<p>To understand tsc_mode completely, some background on TSC is required:</p>

<p>The x86 &quot;timestamp counter&quot;, or TSC, is a 64-bit register on each processor that increases monotonically. Historically, TSC incremented every processor cycle, but on recent processors, it increases at a constant rate even if the processor changes frequency (for example, to reduce processor power usage). TSC is known by x86 programmers as the fastest, highest-precision measurement of the passage of time so it is often used as a foundation for performance monitoring. And since it is guaranteed to be monotonically increasing and, at 64 bits, is guaranteed to not wraparound within 10 years, it is sometimes used as a random number or a unique sequence identifier, such as to stamp transactions so they can be replayed in a specific order.</p>

<p>On most older SMP and early multi-core machines, TSC was not synchronized between processors. Thus if an application were to read the TSC on one processor, then was moved by the OS to another processor, then read TSC again, it might appear that &quot;time went backwards&quot;. This loss of monotonicity resulted in many obscure application bugs when TSC-sensitive apps were ported from a uniprocessor to an SMP environment; as a result, many applications -- especially in the Windows world -- removed their dependency on TSC and replaced their timestamp needs with OS-specific functions, losing both performance and precision. On some more recent generations of multi-core machines, especially multi-socket multi-core machines, the TSC was synchronized but if one processor were to enter certain low-power states, its TSC would stop, destroying the synchrony and again causing obscure bugs. This reinforced decisions to avoid use of TSC altogether. On the most recent generations of multi-core machines, however, synchronization is provided across all processors in all power states, even on multi-socket machines, and provide a flag that indicates that TSC is synchronized and &quot;invariant&quot;. Thus TSC is once again useful for applications, and even newer operating systems are using and depending upon TSC for critical timekeeping tasks when running on these recent machines.</p>

<p>We will refer to hardware that ensures TSC is both synchronized and invariant as &quot;TSC-safe&quot; and any hardware on which TSC is not (or may not remain) synchronized as &quot;TSC-unsafe&quot;.</p>

<p>As a result of TSC&#39;s sordid history, two classes of applications use TSC: old applications designed for single processors, and the most recent enterprise applications which require high-frequency high-precision timestamping.</p>

<p>We will refer to apps that might break if running on a TSC-unsafe machine as &quot;TSC-sensitive&quot;; apps that don&#39;t use TSC, or do use TSC but use it in a way that monotonicity and frequency invariance are unimportant as &quot;TSC-resilient&quot;.</p>

<p>The emergence of virtualization once again complicates the usage of TSC. When features such as save/restore or live migration are employed, a guest OS and all its currently running applications may be invisibly transported to an entirely different physical machine. While TSC may be &quot;safe&quot; on one machine, it is essentially impossible to precisely synchronize TSC across a data center or even a pool of machines. As a result, when run in a virtualized environment, rare and obscure &quot;time going backwards&quot; problems might once again occur for those TSC-sensitive applications. Worse, if a guest OS moves from, for example, a 3GHz machine to a 1.5GHz machine, attempts by an OS/app to measure time intervals with TSC may without notice be incorrect by a factor of two.</p>

<p>The rdtsc (read timestamp counter) instruction is used to read the TSC register. The rdtscp instruction is a variant of rdtsc on recent processors. We refer to these together as the rdtsc family of instructions, or just &quot;rdtsc&quot;. Instructions in the rdtsc family are non-privileged, but privileged software may set a cpuid bit to cause all rdtsc family instructions to trap. This trap can be detected by Xen, which can then transparently &quot;emulate&quot; the results of the rdtsc instruction and return control to the code following the rdtsc instruction.</p>

<p>To provide a &quot;safe&quot; TSC, i.e. to ensure both TSC monotonicity and a fixed rate, Xen provides rdtsc emulation whenever necessary or when explicitly specified by a per-VM configuration option. TSC emulation is relatively slow -- roughly 15-20 times slower than the rdtsc instruction when executed natively. However, except when an OS or application uses the rdtsc instruction at a high frequency (e.g. more than about 10,000 times per second per processor), this performance degradation is not noticeable (i.e. &lt;0.3%). And, TSC emulation is nearly always faster than OS-provided alternatives (e.g. Linux&#39;s gettimeofday). For environments where it is certain that all apps are TSC-resilient (e.g. &quot;TSC-safeness&quot; is not necessary) and highest performance is a requirement, TSC emulation may be entirely disabled (tsc_mode==2).</p>

<p>The default mode (tsc_mode==0) checks TSC-safeness of the underlying hardware on which the virtual machine is launched. If it is TSC-safe, rdtsc will execute at hardware speed; if it is not, rdtsc will be emulated. Once a virtual machine is save/restored or migrated, however, there are two possibilities: TSC remains native IF the source physical machine and target physical machine have the same TSC frequency (or, for HVM/PVH guests, if TSC scaling support is available); else TSC is emulated. Note that, though emulated, the &quot;apparent&quot; TSC frequency will be the TSC frequency of the initial physical machine, even after migration.</p>

<p>Finally, tsc_mode==1 always enables TSC emulation, regardless of the underlying physical hardware. The &quot;apparent&quot; TSC frequency will be the TSC frequency of the initial physical machine, even after migration. This mode is useful to measure any performance degradation that might be encountered by a tsc_mode==0 domain after migration occurs, or a tsc_mode==3 domain when it is running on TSC-unsafe hardware.</p>

<p>Note that while Xen ensures that an emulated TSC is &quot;safe&quot; across migration, it does not ensure that it continues to tick at the same rate during the actual migration. As an oversimplified example, if TSC is ticking once per second in a guest, and the guest is saved when the TSC is 1000, then restored 30 seconds later, TSC is only guaranteed to be greater than or equal to 1001, not precisely 1030. This has some OS implications as will be seen in the next section.</p>

<h1 id="TSC-INVARIANT-BIT-and-NO_MIGRATE">TSC INVARIANT BIT and NO_MIGRATE</h1>

<p>Related to TSC emulation, the &quot;TSC Invariant&quot; bit is architecturally defined in a cpuid bit on the most recent x86 processors. If set, TSC invariance ensures that the TSC is &quot;safe&quot;, that is it will increment at a constant rate regardless of power events, will be synchronized across all processors, and was properly initialized to zero on all processors at boot-time by system hardware/BIOS. As long as system software never writes to TSC, TSC will be safe and continuously incremented at a fixed rate and thus can be used as a system &quot;clocksource&quot;.</p>

<p>This bit is used by some OS&#39;s, and specifically by Linux starting with version 2.6.30(?), to select TSC as a system clocksource. Once selected, TSC remains the Linux system clocksource unless manually overridden. In a virtualized environment, since it is not possible to synchronize TSC across all the machines in a pool or data center, a migration may &quot;break&quot; TSC as a usable clocksource; while time will not go backwards, it may not track wallclock time well enough to avoid certain time-sensitive consequences. As a result, Xen can only expose the TSC Invariant bit to a guest OS if it is certain that the domain will never migrate. As of Xen 4.0, the &quot;no_migrate=1&quot; VM configuration option may be specified to disable migration. If no_migrate is selected and the VM is running on a physical machine with &quot;TSC Invariant&quot;, Linux 2.6.30+ will safely use TSC as the system clocksource. But, attempts to migrate or, once saved, restore this domain will fail.</p>

<p>There is another cpuid-related complication: The x86 cpuid instruction is non-privileged. HVM domains are configured to always trap this instruction to Xen, where Xen can &quot;filter&quot; the result. In a PV OS, all cpuid instructions have been replaced by a paravirtualized equivalent of the cpuid instruction (&quot;pvcpuid&quot;) and also trap to Xen. But apps in a PV guest that use a cpuid instruction execute it directly, without a trap to Xen. As a result, an app may directly examine the physical TSC Invariant cpuid bit and make decisions based on that bit.</p>

<h1 id="HARDWARE-TSC-SCALING">HARDWARE TSC SCALING</h1>

<p>Intel VMX TSC scaling and AMD SVM TSC ratio allow the guest TSC read by guest rdtsc/p increasing in a different frequency than the host TSC frequency.</p>

<p>If a HVM container in default TSC mode (tsc_mode=0) is created on a host that provides constant TSC, its guest TSC frequency will be the same as the host. If it is later migrated to another host that provides constant TSC and supports Intel VMX TSC scaling/AMD SVM TSC ratio, its guest TSC frequency will be the same before and after migration.</p>

<p>For above HVM container in default TSC mode (tsc_mode=0), if above hosts support rdtscp, both guest rdtsc and rdtscp instructions will be executed natively before and after migration.</p>

<h1 id="AUTHORS">AUTHORS</h1>

<p>Dan Magenheimer &lt;dan.magenheimer@oracle.com&gt;</p>


</body>

</html>


