<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
</head>
<body>
<div id="TOC">
<ul>
<li><a href="#argo"><span class="toc-section-number">1</span> Argo</a><ul>
<li><a href="#introduction"><span class="toc-section-number">1.1</span> Introduction</a></li>
<li><a href="#hypervisor-mediated-data-exchange-hmx"><span class="toc-section-number">1.2</span> Hypervisor-Mediated data eXchange (HMX)</a></li>
</ul></li>
<li><a href="#locking"><span class="toc-section-number">2</span> Locking</a><ul>
<li><a href="#structure"><span class="toc-section-number">2.1</span> Structure</a></li>
<li><a href="#protected-state"><span class="toc-section-number">2.2</span> Protected State</a><ul>
<li><a href="#state-rings-registered-and-owned-by-a-domain"><span class="toc-section-number">2.2.1</span> State: Rings registered and owned by a domain</a></li>
<li><a href="#state-partner-rings-for-which-this-domain-is-the-single-allowed-sender"><span class="toc-section-number">2.2.2</span> State: Partner rings for which this domain is the single allowed sender</a></li>
<li><a href="#state-pending-notifications-for-wildcard-rings-registered-by-other-domains"><span class="toc-section-number">2.2.3</span> State: Pending notifications for wildcard rings registered by other domains</a></li>
</ul></li>
<li><a href="#hierarchical-locking-model-and-protocol"><span class="toc-section-number">2.3</span> Hierarchical Locking Model and Protocol</a></li>
<li><a href="#lock-definitions"><span class="toc-section-number">2.4</span> Lock Definitions</a><ul>
<li><a href="#the-global-singleton-lock"><span class="toc-section-number">2.4.1</span> The global singleton lock:</a></li>
<li><a href="#per-domain-ring-hash-lock"><span class="toc-section-number">2.4.2</span> Per-Domain: Ring hash lock</a></li>
<li><a href="#send-hash-lock"><span class="toc-section-number">2.4.3</span> Send hash lock</a></li>
<li><a href="#wildcard-pending-list-lock"><span class="toc-section-number">2.4.4</span> Wildcard pending list lock</a></li>
<li><a href="#per-ring-locks"><span class="toc-section-number">2.4.5</span> Per-Ring locks:</a></li>
</ul></li>
<li><a href="#reasoning-model"><span class="toc-section-number">2.5</span> Reasoning Model</a></li>
<li><a href="#macros-to-validate-and-document-lock-state"><span class="toc-section-number">2.6</span> Macros to Validate and Document Lock State</a></li>
<li><a href="#faq-other-considerations"><span class="toc-section-number">2.7</span> FAQ / Other Considerations</a><ul>
<li><a href="#why-not-have-a-single-per-domain-lock"><span class="toc-section-number">2.7.1</span> Why not have a single per-domain lock?</a></li>
</ul></li>
<li><a href="#rationale-for-using-a-singleton-global-lock-l1"><span class="toc-section-number">2.8</span> Rationale for Using a Singleton Global Lock: L1</a><ul>
<li><a href="#teardown-on-domain-destroy"><span class="toc-section-number">2.8.1</span> Teardown on domain destroy</a></li>
</ul></li>
</ul></li>
<li><a href="#future-work"><span class="toc-section-number">3</span> Future Work</a></li>
</ul>
</div>
<h1 id="argo"><span class="header-section-number">1</span> Argo</h1>
<h2 id="introduction"><span class="header-section-number">1.1</span> Introduction</h2>
<p>Argo is an interdomain communication mechanism. It provides Xen hypervisor primitives to transmit data between VMs, by performing data copies into receive memory rings registered by domains. It does not require memory sharing between VMs and does not use the grant tables or Xenstore.</p>
<p>Argo has requirements for performance isolation between domains, to prevent negative performance impact from malicious or disruptive activity of other domains, or even other VCPUs of the same domain operating other rings.</p>
<h2 id="hypervisor-mediated-data-exchange-hmx"><span class="header-section-number">1.2</span> Hypervisor-Mediated data eXchange (HMX)</h2>
<p>This term references inter-VM communication protocols that have this key architectural point: The hypervisor is responsible for performing the write of data into the guest-accessible memory buffer, in the manner according to the agreed transfer protocol. This structure ensures that there is strength to the transport mechanism, because the transmitting side of the communication is the hypervisor, which can be trusted by the receiver, and the buffer is isolated from access by any other potential sources outside the receiver.</p>
<p>The receiver can trust that the hypervisor will:</p>
<ul>
<li>Provide a protocol implementation adhering to hardware synchronization requirements for concurrent access to system memory by communicating components</li>
<li>Deliver data only from an approved source, enforcing policy for Mandatory Access Control.</li>
<li>Indicate the correct sender of the data.</li>
<li>Transmit only the intended data, adhering to the access protocol of the data structure in the buffer. If the memory region is being used as a ring, then:
<ul>
<li>Data writes will only occur within the ring region that is indicated as available for incoming data by the ring indexes.</li>
<li>The indicated length of data written will exactly match the length of data actually written.</li>
<li>The write for each piece of data will occur only once.</li>
<li>Data will be written sequentially in the order that it is sent.</li>
</ul></li>
<li>Issue notification of data delivered correctly.</li>
</ul>
<p>This structure allows for augmentation by the hypervisor to identify the sending entity within the source VM, and then provide the receiver with assured context information about the data source. This enables the receiver to make decisions based on fine-grained knowledge of the source of the data.</p>
<p>This structure is also of strong interest for nested virtualization: transport via the hypervisor can enable construction of efficient communications between VMs at different levels of nesting.</p>
<h1 id="locking"><span class="header-section-number">2</span> Locking</h1>
<p>Since Argo operates a data path between domains, sections of this code are <em>hot</em> when the communication paths are in use. To encourage high performance, a goal is to limit mutual exclusion to only where required and enable significant concurrency.</p>
<p>Avoidance of deadlock is essential and since state must frequently be updated that pertains to more than one domain, a locking protocol defines which locks are needed and the order of their acquistion.</p>
<h2 id="structure"><span class="header-section-number">2.1</span> Structure</h2>
<p>The granular locking structure of Argo enables:</p>
<ol style="list-style-type: decimal">
<li>Performance isolation of guests</li>
<li>Avoidance of DoS of rings by domains that are not authorized to send to them</li>
<li>Deadlock-free teardown of state across multiple domains on domain destroy</li>
<li>Performance of guests using Argo with concurrent operation of rings.</li>
</ol>
<p>Argo uses three per-domain locks to protect three separate data structures. Access to the ring_hash data structure is confined to domains that a ring-registering domain has authorized to send data via the ring. The complete set of Argo locks is:</p>
<ul>
<li>Global : <code>L1_global_argo_rwlock</code></li>
<li>Per-domain: <code>rings_L2_rwlock</code></li>
<li>Per-domain: <code>send_L2_lock</code></li>
<li>Per-domain: <code>wildcard_L2_lock</code></li>
<li>Per-ring: <code>L3_lock</code></li>
</ul>
<h2 id="protected-state"><span class="header-section-number">2.2</span> Protected State</h2>
<p>The data structures being protected by the locks are all per-domain. The only global Argo state is the <code>L1_global_argo_rwlock</code> used to coordinate access to data structures of other domains.</p>
<h3 id="state-rings-registered-and-owned-by-a-domain"><span class="header-section-number">2.2.1</span> State: Rings registered and owned by a domain</h3>
<p>This includes the state to run that ring, such as memory frame numbers and established mappings. Per-ring state is protected by its own lock, so that multiple VCPUs of the same domain operating different rings do not inhibit the performance of each other.</p>
<p>The per-domain ring state also includes the list of pending notifications for other domains that are waiting for ring space availability.</p>
<h3 id="state-partner-rings-for-which-this-domain-is-the-single-allowed-sender"><span class="header-section-number">2.2.2</span> State: Partner rings for which this domain is the single allowed sender</h3>
<p>This state belonging to the permitted sender is written to when a ring is registered by another domain. The lock that protects this state is subject to locking at arbitrary frequency by those foreign domains when registering rings -- which do not need any permission granted by this domain in order to register a ring to communicate with it -- so it must not inhibit the domain's own ability to use its own rings, to protect them from DoS. For this reason, this state is protected by its own lock.</p>
<h3 id="state-pending-notifications-for-wildcard-rings-registered-by-other-domains"><span class="header-section-number">2.2.3</span> State: Pending notifications for wildcard rings registered by other domains</h3>
<p>This data structure is needed when a domain is destroyed, to cancel the outstanding space availability notifications about the wildcard rings of other domains that this domain has queried.</p>
<p>Data is entered into this data structure by the domain that owns it, either by a space-inhibited sendv or a notify operation.</p>
<p>Data is removed from this data structure in one of three cases: when space becomes available in the destination ring and the notification is sent, when the ring is torn down, or when the awaiting domain is destroyed.</p>
<p>In the case where a notification is sent, access to the data structure is triggered by the ring owner domain, rather than the domain waiting for notification. This data structure is protected by its own lock since doing so entails less contention than the alternative of reusing an existing lock owned by the domain.</p>
<h2 id="hierarchical-locking-model-and-protocol"><span class="header-section-number">2.3</span> Hierarchical Locking Model and Protocol</h2>
<p>The locking discipline within the Argo code is heirarchical and utilizes reader/writer locks to enable increased concurrency when operations do not conflict. None of the Argo locks are reentrant.</p>
<p>The hierarchy:</p>
<ul>
<li>There is a global rwlock (<code>L1</code>) to protect access to all of the per-domain argo data structures.</li>
<li>There is a rwlock per-domain (<code>rings_L2</code>) to protect the hashtable of the per-ring data structures.</li>
<li>There is a lock per ring (<code>L3</code>) to protect the per-ring data structure, <code>struct argo_ring_info</code>.</li>
</ul>
<p>There are a two other per-domain L2 locks; their operation is similar and they are described later.</p>
<p>The protocol to safely acquire write access to the per-ring data structure, <code>struct argo_ring_info</code>, is:</p>
<ol style="list-style-type: decimal">
<li>Acquire a Read lock on L1.</li>
<li>Acquire a Read lock on L2.</li>
<li>Acquire L3.</li>
</ol>
<p>An alternative valid sequence is:</p>
<ol style="list-style-type: decimal">
<li>Acquire a Read lock on L1.</li>
<li>Acquire a Write lock on L2.</li>
</ol>
<p>This second sequence grants write access to <em>all</em> of the <code>argo_ring_info</code> structs belonging to the domain, but at the expense of less concurrency: no other operation can access those structs while the locks are held, which will inhibit operations on those rings until the locks are released.</p>
<p>Another alternative valid sequence is:</p>
<ol style="list-style-type: decimal">
<li>Acquire a Write lock on L1.</li>
</ol>
<p>This grants write access to <em>all</em> of the <code>argo_ring_info</code> structs belonging to <em>all domains</em>, but again at the expense of far less concurrency: no other operation can operate on Argo rings until the locks are released.</p>
<h2 id="lock-definitions"><span class="header-section-number">2.4</span> Lock Definitions</h2>
<p>The full set of locks that are directly operated upon by the Argo code are described in the following section.</p>
<h3 id="the-global-singleton-lock"><span class="header-section-number">2.4.1</span> The global singleton lock:</h3>
<ul>
<li><code>L1_global_argo_rwlock</code></li>
</ul>
<p>The rationale for having a global lock is to be able to enforce system-wide exclusion for a critical region and simplify the logic required to avoid deadlock, for teardown of state across multiple domains when a domain is destroyed.</p>
<p>The majority of operations take a read-lock on this lock, allowing concurrent Argo operations by many domains.</p>
<p>The pointer d-&gt;argo on every domain is protected by this lock. A set of more granular per-domain locks could be used to do that, but since domain start and stop is expected to be a far less frequent operation than the other argo operations, acquiring a single read lock to enable access to all the argo structs of all domains simplifies the protocol.</p>
<p>Points of write-locking on this lock:</p>
<ul>
<li><code>argo_destroy</code>, where:</li>
<li>All of the domain's own rings are destroyed.
<ul>
<li>All of the notifications pending for other domains are cancelled.</li>
</ul></li>
<li>All of the unicast partner rings owned by other domains for this domain to send to, are destroyed.
<ul>
<li>All of the notifications pending on those rings are cancelled.</li>
</ul></li>
<li>All of the notifications pending for this domain on wildcard rings owned by other domains are cancelled.</li>
<li><code>argo_soft_reset</code>, for similar teardown operations as argo_destroy.</li>
<li><code>argo_init</code>, where the <code>d-&gt;argo</code> pointer is first populated.</li>
<li>Since the write lock is taken here, there is serialization all concurrent Argo operations around this single pointer write; this is the cost of using the simpler one global lock approach.</li>
</ul>
<p>Enforcing that the write_lock is acquired on <code>L1_global_argo_rwlock</code> before executing teardown, ensures that no teardown operations act concurrently and no other Argo operations happen concurrently with a teardown. The teardown logic is free to safely modify the Argo state across all domains without having to acquire per-domain locks and deadlock cannot occur.</p>
<h3 id="per-domain-ring-hash-lock"><span class="header-section-number">2.4.2</span> Per-Domain: Ring hash lock</h3>
<p><code>rings_L2_rwlock</code></p>
<p>Protects: the per-domain ring hash table of <code>argo_ring_info</code> structs.</p>
<p>Holding a read lock on <code>rings_L2</code> protects the ring hash table and the elements in the hash table <code>d-&gt;argo-&gt;ring_hash</code>, and the <code>node</code> and <code>id</code> fields in struct <code>argo_ring_info</code> in the hash table.</p>
<p>Holding a write lock on <code>rings_L2</code> protects all of the elements of all the struct <code>argo_ring_info</code> belonging to this domain.</p>
<p>To take <code>rings_L2</code> you must already have <code>R(L1)</code>. <code>W(L1)</code> implies <code>W(rings_L2)</code> and <code>L3</code>.</p>
<p>Prerequisites:</p>
<ul>
<li><code>R(L1_global_argo_rwlock)</code> must be acquired before taking either read or write on <code>rings_L2_rwlock</code>.</li>
<li><code>W(L1_global_argo_rwlock)</code> implies <code>W(rings_L2_rwlock)</code>, so if <code>W(L1_global_argo_rwlock)</code> is held, then <code>rings_L2_rwlock</code> does not need to be acquired, and all the data structures that <code>rings_L2_rwlock</code> protects can be accessed as if <code>W(ring_L2_rwlock)</code> was held.</li>
</ul>
<p>Is accessed by the hypervisor on behalf of:</p>
<ul>
<li>The domain that registered the ring.</li>
<li>Any domain that is allowed to send to the ring -- so that's the partner domain, for unicast rings, or any domain, for wildcard rings.</li>
</ul>
<h3 id="send-hash-lock"><span class="header-section-number">2.4.3</span> Send hash lock</h3>
<p><code>send_L2_lock</code></p>
<p>Protects: the per-domain send hash table of <code>argo_send_info</code> structs.</p>
<p>Is accessed by the hypervisor on behalf of:</p>
<ul>
<li>Any domain that registers a ring that specifies the domain as the unicast sender.</li>
<li>The domain that has been allowed to send, as part of teardown when the domain is being destroyed.</li>
</ul>
<h3 id="wildcard-pending-list-lock"><span class="header-section-number">2.4.4</span> Wildcard pending list lock</h3>
<p><code>wildcard_L2_lock</code></p>
<p>Protects: the per-domain list of pending notifications to the domain from wildcard rings owned by other domains.</p>
<p>Is accessed by the hypervisor on behalf of:</p>
<ul>
<li>The domain that issued a query to another about space availability in one of its wildcard rings - this can be done by attempting a send operation when there is insufficient ring space available at the time.</li>
<li>Any domain that the domain has issued a query to about space availability in one of their wildcard rings.</li>
</ul>
<h3 id="per-ring-locks"><span class="header-section-number">2.4.5</span> Per-Ring locks:</h3>
<ul>
<li><code>L3_lock</code></li>
</ul>
<p>This lock protects the members of a <code>struct ring_info</code> which is the primary state for a domain's own registered ring.</p>
<h2 id="reasoning-model"><span class="header-section-number">2.5</span> Reasoning Model</h2>
<p>A common model for reasoning about concurrent code focusses on accesses to individual variables: if code touches this variable, see that it first acquires the corresponding lock and then drops it afterwards. A challenge with this model is in ensuring that the sequence of locks acquired within nested functions, when operating on data from multiple domains with concurrent operations, is safe from deadlock.</p>
<p>An alternative method that is better suited to the Argo software is to consider the execution path, the full sequence of locks acquired, accesses performed, and locks released, from entering an operation, to the completion of the work.</p>
<p>An example code path for an operation:</p>
<p><code>[entry] &gt; -- [ take R(L1) ] -- [ take R(L2) ] -- loop [ take a L3 / drop L3 ] --  [ drop R(L2) ] -- [ drop R(L1)] -- &gt; [exit]</code></p>
<p>If a function implements a section of the path, it is important to know not only what variables the function itself operates upon, but also the locking state that will already have been established at the point when the function is invoked, since this will affect what data the function can access. For this reason, comments in the code, or ASSERTs that explicitly check lock state, communicate what the locking state is expected and intended to be when that code is invoked. See the macros defined to support this for Argo later in this document.</p>
<h2 id="macros-to-validate-and-document-lock-state"><span class="header-section-number">2.6</span> Macros to Validate and Document Lock State</h2>
<p>These macros encode the logic to verify that the locking has adhered to the locking discipline.</p>
<p>eg. On entry to logic that requires holding at least <code>R(rings_L2)</code>, this:</p>
<p><code>ASSERT(LOCKING_Read_rings_L2(d));</code></p>
<p>checks that the lock state is sufficient, validating that one of the following must be true when executed:</p>
<p><code>R(rings_L2) &amp;&amp; R(L1)</code> or: <code>W(rings_L2) &amp;&amp; R(L1)</code> or: <code>W(L1)</code></p>
<p>The macros are defined thus:</p>
<pre><code>#define LOCKING_Write_L1 (rw_is_write_locked(&amp;L1_global_argo_rwlock))
/*
 * While LOCKING_Read_L1 will return true even if the lock is write-locked,
 * that&#39;s OK because everywhere that a Read lock is needed with these macros,
 * holding a Write lock there instead is OK too: we&#39;re checking that _at least_
 * the specified level of locks are held.
 */
#define LOCKING_Read_L1 (rw_is_locked(&amp;L1_global_argo_rwlock))

#define LOCKING_Write_rings_L2(d) \
    ((LOCKING_Read_L1 &amp;&amp; rw_is_write_locked(&amp;(d)-&gt;argo-&gt;rings_L2_rwlock)) || \
     LOCKING_Write_L1)
/*
 * Skip checking LOCKING_Write_rings_L2(d) within this LOCKING_Read_rings_L2
 * definition because the first clause that is testing R(L1) &amp;&amp; R(L2) will also
 * return true if R(L1) &amp;&amp; W(L2) is true, because of the way that rw_is_locked
 * behaves. This results in a slightly shorter and faster implementation.
 */
#define LOCKING_Read_rings_L2(d) \
    ((LOCKING_Read_L1 &amp;&amp; rw_is_locked(&amp;(d)-&gt;argo-&gt;rings_L2_rwlock)) || \
     LOCKING_Write_L1)
/*
 * Skip checking LOCKING_Write_L1 within this LOCKING_L3 definition because
 * LOCKING_Write_rings_L2(d) will return true for that condition.
 */
#define LOCKING_L3(d, r) \
    ((LOCKING_Read_L1 &amp;&amp; rw_is_locked(&amp;(d)-&gt;argo-&gt;rings_L2_rwlock) \
      &amp;&amp; spin_is_locked(&amp;(r)-&gt;L3_lock)) || LOCKING_Write_rings_L2(d))

#define LOCKING_send_L2(d) \
    ((LOCKING_Read_L1 &amp;&amp; spin_is_locked(&amp;(d)-&gt;argo-&gt;send_L2_lock)) || \
     LOCKING_Write_L1)</code></pre>
<p>Here is an example of a macro in use:</p>
<pre><code>static void
notify_ring(const struct domain *d, struct argo_ring_info *ring_info,
          struct hlist_head *to_notify)
{
  uint32_t space;

  ASSERT(LOCKING_Read_rings_L2(d));

  spin_lock(&amp;ring_info-&gt;L3_lock);

  if ( ring_info-&gt;len )
      space = ringbuf_payload_space(d, ring_info);
  else
      space = 0;

  spin_unlock(&amp;ring_info-&gt;L3_lock);

  if ( space )
      pending_find(d, ring_info, space, to_notify);
}
</code></pre>
<p>In the above example, it can be seen that it is safe to acquire the <code>L3</code> lock because <em>at least</em> <code>R(rings_L2)</code> is already held, as documented and verified by the macro.</p>
<h2 id="faq-other-considerations"><span class="header-section-number">2.7</span> FAQ / Other Considerations</h2>
<h3 id="why-not-have-a-single-per-domain-lock"><span class="header-section-number">2.7.1</span> Why not have a single per-domain lock?</h3>
<p>Due to performance isolation / DoS avoidance: if there is a single per-domain lock, acquiring this lock will stall operations on other active rings owned by the domain. A malicious domain can loop registering and unregistering rings, without any consent by the targetted domain, which would experience decreased throughput due to the contention on the single per-domain lock. The granular locking structure of Argo prevents this. It also allows concurrent operation of different rings by multiple VCPUs of the same domain without contention, to avoid negative application performance interaction.</p>
<h2 id="rationale-for-using-a-singleton-global-lock-l1"><span class="header-section-number">2.8</span> Rationale for Using a Singleton Global Lock: L1</h2>
<h3 id="teardown-on-domain-destroy"><span class="header-section-number">2.8.1</span> Teardown on domain destroy</h3>
<p>The single global lock enables exclusive access to the argo data structures across domains when a domain is destroyed. Every unicast ring that the dying domain is the authorized sender is torn down and any pending space-available notifications in other domain's wildcard rings are cancelled. This requires gaining safe access to the data structures on each of the domains involved.</p>
<p>The 'send hashtable' data structure is needed in order to perform the teardown of rings when a domain is destroyed. To populate it, whenever a unicast ring is registered, the lock that protects that data structure must be taken exclusively.</p>
<p>There are granular per-domain locks which protect the per-domain data structures. The global singleton L1 lock operates with-and-above the per-domain locks and is used to obtain exclusive access to multiple domain's argo data structures in the infrequent case where it is used -- for domain destroy -- whilst otherwise allowing concurrent access, via acquiring it with 'read' access, for the majority of the time.</p>
<p>To perform the required state teardown on domain destruction, which can require removing state from the data structures of multiple domains, a locking protocol to obtain mutual exclusion and safe access to the state is required, without deadlocking.</p>
<p>Using the single global lock avoids the need for sequencing the acquisition of multiple individual per-domain locks (and lower level data structure locks) to prevent deadlock: taking W(L1) grants access to all and taking R(L1) ensures that teardown of any domain will not interfere with any Argo hypercall operation. It enables introducing granular locking without complex or error-prone lock acquisition logic.</p>
<h1 id="future-work"><span class="header-section-number">3</span> Future Work</h1>
<ul>
<li>Performance measurement and optimization</li>
<li>Provide assurance of connection source context to destination</li>
<li>Policy controls for reducing the duration of hypervisor mappings of transmission rings, to improve resistance to data read attacks on hypervisor memory</li>
</ul>
</body>
</html>
